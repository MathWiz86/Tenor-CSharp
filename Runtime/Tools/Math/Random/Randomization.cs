/**************************************************************************************************/
/*!
\file   Randomization.cs
\author Craig Williams
\par    Last Updated
        2021-03-07
\par    Copyright
        Copyright © 2021 Craig Joseph Williams, All Rights Reserved.

\brief
  A file for helper functions for randomly generating values. This also contains references to
  global random generators for use in an entire project.

\par Bug List

\par References
  - https://docs.microsoft.com/en-us/archive/msdn-magazine/2007/september/net-matters-tales-from-the-cryptorandom
  - https://stackoverflow.com/questions/2854438/how-to-generate-a-cryptographically-secure-double-between-0-and-1
*/
/**************************************************************************************************/

using System;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using Tenor.Error;
using Tenor.Tools.Collection;

namespace Tenor.Tools.Math
{
  public static partial class Randomization
  {
    /// <summary>A global random number generator, based on the .NET standard class.</summary>
    private static System.Random StandardGenerator = null;
    /// <summary>A global random number generator, based on the rejection method.</summary>
    private static RejectionRandom RejectionGenerator = null;
    /// <summary>A global random number generator, based on the .NET cryptography class.</summary>
    private static RNGCryptoServiceProvider CryptoGenerator = null;

    /// <summary>
    /// The static constructor for the <see cref="Randomization"/> tool.
    /// </summary>
    static Randomization()
    {
      StandardGenerator = new System.Random();
      RejectionGenerator = new RejectionRandom();
      CryptoGenerator = new RNGCryptoServiceProvider();
    }

    /// <summary>
    /// A function to reset the global standard generator with a new seed. This uses the current
    /// <see cref="System.Environment.TickCount"/> for the seed.
    /// </summary>
    public static void ResetStandardGenerator()
    {
      StandardGenerator = new System.Random();
    }

    /// <summary>
    /// A function to reset the global standard generator with a new seed.
    /// </summary>
    /// <param name="seed">The new seed to use for the generator.</param>
    public static void ResetStandardGenerator(int seed)
    {
      StandardGenerator = new System.Random(seed);
    }

    /// <summary>
    /// A function to reset the global rejection generator with a new seed. This uses the current
    /// <see cref="System.Environment.TickCount"/> for the seed.
    /// </summary>
    public static void ResetRejectionGenerator()
    {
      RejectionGenerator = new RejectionRandom();
    }

    /// <summary>
    /// A function to reset the global rjection generator with a new seed.
    /// </summary>
    /// <param name="seed">The new seed to use for the generator.</param>
    public static void ResetRejectionGenerator(int seed)
    {
      RejectionGenerator = new RejectionRandom(seed);
    }

    /// <summary>
    /// A function to reset the global crypto generator.
    /// </summary>
    public static void ResetCryptoGenerator()
    {
      CryptoGenerator = new RNGCryptoServiceProvider();
    }

    /// <summary>
    /// A function for generating random values, and storing them into a byte array.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="bytes">The array to store the values into. This must be sized to the number of
    /// bytes to generate.</param>
    public static void GetRandomBytes(this System.Random random, byte[] bytes)
    {
      // If the generator and count are valid, create an array of random bytes.
      if (random != null && !bytes.IsEmptyOrNull())
        random.InternalGetRandomBytes(bytes);
    }

    /// <summary>
    /// A function for generating random values, and storing them into a byte array.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="count">The number of bytes to generate. This must be greater than 0.</param>
    /// <param name="bytes">The array of generated bytes.</param>
    public static void GetRandomBytes(this System.Random random, int count, out byte[] bytes)
    {
      bytes = null; // Initialize bytes.

      // If the generator and count are valid, create an array of random bytes.
      if (random != null && count > 0)
        random.InternalGetRandomBytes(count, out bytes);
    }

    /// <summary>
    /// A function for generating random values, and storing them into a byte array.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="count">The number of bytes to generate. This must be greater than 0.</param>
    /// <returns>Returns the generated byte array.</returns>
    public static byte[] GetRandomBytes(this System.Random random, int count)
    {
      // If the generator is valid, and the count is valid, generate the bytes.
      return (random != null && count > 0) ? random.InternalGetRandomBytes(count) : null;
    }

    /// <summary>
    /// A function for generating random values, and storing them into a byte array.
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="bytes">The array to store the values into. This must be sized to the number of
    /// bytes to generate.</param>
    public static void GetRandomBytes(this RandomNumberGenerator random, byte[] bytes)
    {
      // If the generator and count are valid, create an array of random bytes.
      if (random != null && !bytes.IsEmptyOrNull())
        random.InternalGetRandomBytes(bytes);
    }

    /// <summary>
    /// A function for generating random values, and storing them into a byte array.
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="count">The number of bytes to generate. This must be greater than 0.</param>
    /// <param name="bytes">The array of generated bytes.</param>
    public static void GetRandomBytes(this RandomNumberGenerator random, int count, out byte[] bytes)
    {
      bytes = null; // Initialize bytes.

      // If the generator and count are valid, create an array of random bytes.
      if (random != null && count > 0)
        random.InternalGetRandomBytes(count, out bytes);
    }

    /// <summary>
    /// A function for generating random values, and storing them into a byte array.
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="count">The number of bytes to generate. This must be greater than 0.</param>
    /// <returns>Returns the generated byte array.</returns>
    public static byte[] GetRandomBytes(this RandomNumberGenerator random, int count)
    {
      // If the generator is valid, and the count is valid, generate the bytes.
      return (random != null && count > 0) ? random.InternalGetRandomBytes(count) : null;
    }

    /// <summary>
    /// A function for generating random values, and storing them into a byte array.
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="bytes">The array to store the values into. This must be sized to the number of
    /// bytes to generate.</param>
    public static void GetRandomBytes(StandardRandomGenerators generator, byte[] bytes)
    {
      if (!bytes.IsEmptyOrNull())
        InternalGetRandomBytes(generator, bytes);
    }

    /// <summary>
    /// A function for generating random values, and storing them into a byte array.
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="count">The number of bytes to generate. This must be greater than 0.</param>
    /// <param name="bytes">The array of generated bytes.</param>
    public static void GetRandomBytes(StandardRandomGenerators generator, int count, out byte[] bytes)
    {
      bytes = null; // Initialize bytes.

      // If the count is valid, create an array of random bytes.
      if (count > 0)
        InternalGetRandomBytes(generator, count, out bytes);
    }

    /// <summary>
    /// A function for generating random values, and storing them into a byte array.
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="count">The number of bytes to generate. This must be greater than 0.</param>
    /// <returns>Returns the generated byte array.</returns>
    public static byte[] GetRandomBytes(StandardRandomGenerators generator, int count)
    {
      // If the count is valid, generate the bytes.
      return count > 0 ? InternalGetRandomBytes(generator, count) : null;
    }

    /// <summary>
    /// A function for generating any <see cref="sbyte"/> on the range of
    /// [<see cref="sbyte.MinValue"/>, <see cref="sbyte.MaxValue"/>].
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="sbyte"/>.</returns>
    /// <exception cref="ArgumentNullException">The random generator is null.</exception>
    public static sbyte GetRandomSByte(this System.Random random)
    {
      // If the generator is not null, return a random sbyte on the full range.
      if (random != null)
        return random.InternalGetRandomSByte();
      // If null, throw an error.
      throw new ArgumentNullException(nameof(random), "Random generator is null.");
    }

    /// <summary>
    /// A function for generating any <see cref="sbyte"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="sbyte"/>.</returns>
    public static sbyte GetRandomSByteII(this System.Random random, sbyte minValue, sbyte maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (sbyte)random.InternalGetRandomIntII(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="sbyte"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="sbyte"/>.</returns>
    public static sbyte GetRandomSByteEE(this System.Random random, sbyte minValue, sbyte maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (sbyte)random.InternalGetRandomIntEE(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="sbyte"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="sbyte"/>.</returns>
    public static sbyte GetRandomSByteIE(this System.Random random, sbyte minValue, sbyte maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (sbyte)random.InternalGetRandomIntIE(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="sbyte"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="sbyte"/>.</returns>
    public static sbyte GetRandomSByteEI(this System.Random random, sbyte minValue, sbyte maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (sbyte)random.InternalGetRandomIntEI(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="sbyte"/> on the range of
    /// [<see cref="sbyte.MinValue"/>, <see cref="sbyte.MaxValue"/>].
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="sbyte"/>.</returns>
    /// <exception cref="ArgumentNullException">The random generator is null.</exception>
    public static sbyte GetRandomSByte(this RandomNumberGenerator random)
    {
      // If the generator is not null, return a random sbyte on the full range.
      if (random != null)
        return random.InternalGetRandomSByte();
      // If null, throw an error.
      throw new ArgumentNullException(nameof(random), "Random generator is null.");
    }

    /// <summary>
    /// A function for generating any <see cref="sbyte"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="sbyte"/>.</returns>
    public static sbyte GetRandomSByteII(this RandomNumberGenerator random, sbyte minValue, sbyte maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (sbyte)random.InternalGetRandomIntII(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="sbyte"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="sbyte"/>.</returns>
    public static sbyte GetRandomSByteEE(this RandomNumberGenerator random, sbyte minValue, sbyte maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (sbyte)random.InternalGetRandomIntEE(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="sbyte"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="sbyte"/>.</returns>
    public static sbyte GetRandomSByteIE(this RandomNumberGenerator random, sbyte minValue, sbyte maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (sbyte)random.InternalGetRandomIntIE(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="sbyte"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="sbyte"/>.</returns>
    public static sbyte GetRandomSByteEI(this RandomNumberGenerator random, sbyte minValue, sbyte maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (sbyte)random.InternalGetRandomIntEI(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="sbyte"/> on the range of
    /// [<see cref="sbyte.MinValue"/>, <see cref="sbyte.MaxValue"/>].
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="sbyte"/>.</returns>
    /// <exception cref="ArgumentNullException">The random generator is null.</exception>
    public static sbyte GetRandomSByte(StandardRandomGenerators generator)
    {
      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => RejectionGenerator.InternalGetRandomSByte(),
        StandardRandomGenerators.CryptoServiceProvider => CryptoGenerator.InternalGetRandomSByte(),
        _ => StandardGenerator.InternalGetRandomSByte(),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="sbyte"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="sbyte"/>.</returns>
    public static sbyte GetRandomSByteII(StandardRandomGenerators generator, sbyte minValue, sbyte maxValue)
    {
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => (sbyte)RejectionGenerator.InternalGetRandomIntII(minValue, maxValue),
        StandardRandomGenerators.CryptoServiceProvider => (sbyte)CryptoGenerator.InternalGetRandomIntII(minValue, maxValue),
        _ => (sbyte)StandardGenerator.InternalGetRandomIntII(minValue, maxValue),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="sbyte"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="sbyte"/>.</returns>
    public static sbyte GetRandomSByteEE(StandardRandomGenerators generator, sbyte minValue, sbyte maxValue)
    {
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => (sbyte)RejectionGenerator.InternalGetRandomIntEE(minValue, maxValue),
        StandardRandomGenerators.CryptoServiceProvider => (sbyte)CryptoGenerator.InternalGetRandomIntEE(minValue, maxValue),
        _ => (sbyte)StandardGenerator.InternalGetRandomIntEE(minValue, maxValue),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="sbyte"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="sbyte"/>.</returns>
    public static sbyte GetRandomSByteIE(StandardRandomGenerators generator, sbyte minValue, sbyte maxValue)
    {
      // Throw an error if the min is greater than or equal to the max.
      if (minValue >= maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range, after adjustment, is equal.
      if (minValue == maxValue - 1)
        return minValue;

      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => (sbyte)RejectionGenerator.InternalGetRandomIntIE(minValue, maxValue),
        StandardRandomGenerators.CryptoServiceProvider => (sbyte)CryptoGenerator.InternalGetRandomIntIE(minValue, maxValue),
        _ => (sbyte)StandardGenerator.InternalGetRandomIntIE(minValue, maxValue),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="sbyte"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="sbyte"/>.</returns>
    public static sbyte GetRandomSByteEI(StandardRandomGenerators generator, sbyte minValue, sbyte maxValue)
    {
      // Throw an error if the min is greater than or equal to the max.
      if (minValue >= maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range, after adjustment, is equal.
      if (minValue + 1 == maxValue)
        return minValue;

      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => (sbyte)RejectionGenerator.InternalGetRandomIntEI(minValue, maxValue),
        StandardRandomGenerators.CryptoServiceProvider => (sbyte)CryptoGenerator.InternalGetRandomIntEI(minValue, maxValue),
        _ => (sbyte)StandardGenerator.InternalGetRandomIntEI(minValue, maxValue),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="byte"/> on the range of
    /// [<see cref="byte.MinValue"/>, <see cref="byte.MaxValue"/>].
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="byte"/>.</returns>
    /// <exception cref="ArgumentNullException">The random generator is null.</exception>
    public static byte GetRandomByte(this System.Random random)
    {
      // If the generator is not null, return a random byte on the full range.
      if (random != null)
        return random.InternalGetRandomByte();
      // If null, throw an error.
      throw new ArgumentNullException(nameof(random), "Random generator is null.");
    }

    /// <summary>
    /// A function for generating any <see cref="byte"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="byte"/>.</returns>
    public static byte GetRandomByteII(this System.Random random, byte minValue, byte maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (byte)random.InternalGetRandomIntII(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="byte"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="byte"/>.</returns>
    public static byte GetRandomByteEE(this System.Random random, byte minValue, byte maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (byte)random.InternalGetRandomIntEE(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="byte"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="byte"/>.</returns>
    public static byte GetRandomByteIE(this System.Random random, byte minValue, byte maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (byte)random.InternalGetRandomIntIE(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="byte"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="byte"/>.</returns>
    public static byte GetRandomByteEI(this System.Random random, byte minValue, byte maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (byte)random.InternalGetRandomIntEI(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="byte"/> on the range of
    /// [<see cref="byte.MinValue"/>, <see cref="byte.MaxValue"/>].
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="byte"/>.</returns>
    /// <exception cref="ArgumentNullException">The random generator is null.</exception>
    public static byte GetRandomByte(this RandomNumberGenerator random)
    {
      // If the generator is not null, return a random byte on the full range.
      if (random != null)
        return random.InternalGetRandomByte();
      // If null, throw an error.
      throw new ArgumentNullException(nameof(random), "Random generator is null.");
    }

    /// <summary>
    /// A function for generating any <see cref="byte"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="byte"/>.</returns>
    public static byte GetRandomByteII(this RandomNumberGenerator random, byte minValue, byte maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (byte)random.InternalGetRandomIntII(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="byte"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="byte"/>.</returns>
    public static byte GetRandomByteEE(this RandomNumberGenerator random, byte minValue, byte maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (byte)random.InternalGetRandomIntEE(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="byte"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="byte"/>.</returns>
    public static byte GetRandomByteIE(this RandomNumberGenerator random, byte minValue, byte maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (byte)random.InternalGetRandomIntIE(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="byte"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="byte"/>.</returns>
    public static byte GetRandomByteEI(this RandomNumberGenerator random, byte minValue, byte maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (byte)random.InternalGetRandomIntEI(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="byte"/> on the range of
    /// [<see cref="byte.MinValue"/>, <see cref="byte.MaxValue"/>].
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="byte"/>.</returns>
    /// <exception cref="ArgumentNullException">The random generator is null.</exception>
    public static byte GetRandomByte(StandardRandomGenerators generator)
    {
      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => RejectionGenerator.InternalGetRandomByte(),
        StandardRandomGenerators.CryptoServiceProvider => CryptoGenerator.InternalGetRandomByte(),
        _ => StandardGenerator.InternalGetRandomByte(),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="byte"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="byte"/>.</returns>
    public static byte GetRandomByteII(StandardRandomGenerators generator, byte minValue, byte maxValue)
    {
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => (byte)RejectionGenerator.InternalGetRandomIntII(minValue, maxValue),
        StandardRandomGenerators.CryptoServiceProvider => (byte)CryptoGenerator.InternalGetRandomIntII(minValue, maxValue),
        _ => (byte)StandardGenerator.InternalGetRandomIntII(minValue, maxValue),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="byte"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="byte"/>.</returns>
    public static byte GetRandomByteEE(StandardRandomGenerators generator, byte minValue, byte maxValue)
    {
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => (byte)RejectionGenerator.InternalGetRandomIntEE(minValue, maxValue),
        StandardRandomGenerators.CryptoServiceProvider => (byte)CryptoGenerator.InternalGetRandomIntEE(minValue, maxValue),
        _ => (byte)StandardGenerator.InternalGetRandomIntEE(minValue, maxValue),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="byte"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="byte"/>.</returns>
    public static byte GetRandomByteIE(StandardRandomGenerators generator, byte minValue, byte maxValue)
    {
      // Throw an error if the min is greater than or equal to the max.
      if (minValue >= maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range, after adjustment, is equal.
      if (minValue == maxValue - 1)
        return minValue;

      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => (byte)RejectionGenerator.InternalGetRandomIntIE(minValue, maxValue),
        StandardRandomGenerators.CryptoServiceProvider => (byte)CryptoGenerator.InternalGetRandomIntIE(minValue, maxValue),
        _ => (byte)StandardGenerator.InternalGetRandomIntIE(minValue, maxValue),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="byte"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="byte"/>.</returns>
    public static byte GetRandomByteEI(StandardRandomGenerators generator, byte minValue, byte maxValue)
    {
      // Throw an error if the min is greater than or equal to the max.
      if (minValue >= maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range, after adjustment, is equal.
      if (minValue + 1 == maxValue)
        return minValue;

      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => (byte)RejectionGenerator.InternalGetRandomIntEI(minValue, maxValue),
        StandardRandomGenerators.CryptoServiceProvider => (byte)CryptoGenerator.InternalGetRandomIntEI(minValue, maxValue),
        _ => (byte)StandardGenerator.InternalGetRandomIntEI(minValue, maxValue),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="short"/> on the range of
    /// [<see cref="short.MinValue"/>, <see cref="short.MaxValue"/>].
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="short"/>.</returns>
    /// <exception cref="ArgumentNullException">The random generator is null.</exception>
    public static short GetRandomShort(this System.Random random)
    {
      // If the generator is not null, return a random short on the full range.
      if (random != null)
        return random.InternalGetRandomShort();
      // If null, throw an error.
      throw new ArgumentNullException(nameof(random), "Random generator is null.");
    }

    /// <summary>
    /// A function for generating any <see cref="short"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="short"/>.</returns>
    public static short GetRandomShortII(this System.Random random, short minValue, short maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (short)random.InternalGetRandomIntII(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="short"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="short"/>.</returns>
    public static short GetRandomShortEE(this System.Random random, short minValue, short maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (short)random.InternalGetRandomIntEE(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="short"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="short"/>.</returns>
    public static short GetRandomShortIE(this System.Random random, short minValue, short maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (short)random.InternalGetRandomIntIE(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="short"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="short"/>.</returns>
    public static short GetRandomShortEI(this System.Random random, short minValue, short maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (short)random.InternalGetRandomIntEI(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="short"/> on the range of
    /// [<see cref="short.MinValue"/>, <see cref="short.MaxValue"/>].
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="short"/>.</returns>
    /// <exception cref="ArgumentNullException">The random generator is null.</exception>
    public static short GetRandomShort(this RandomNumberGenerator random)
    {
      // If the generator is not null, return a random short on the full range.
      if (random != null)
        return random.InternalGetRandomShort();
      // If null, throw an error.
      throw new ArgumentNullException(nameof(random), "Random generator is null.");
    }

    /// <summary>
    /// A function for generating any <see cref="short"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="short"/>.</returns>
    public static short GetRandomShortII(this RandomNumberGenerator random, short minValue, short maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (short)random.InternalGetRandomIntII(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="short"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="short"/>.</returns>
    public static short GetRandomShortEE(this RandomNumberGenerator random, short minValue, short maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (short)random.InternalGetRandomIntEE(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="short"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="short"/>.</returns>
    public static short GetRandomShortIE(this RandomNumberGenerator random, short minValue, short maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (short)random.InternalGetRandomIntIE(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="short"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="short"/>.</returns>
    public static short GetRandomShortEI(this RandomNumberGenerator random, short minValue, short maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (short)random.InternalGetRandomIntEI(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="short"/> on the range of
    /// [<see cref="short.MinValue"/>, <see cref="short.MaxValue"/>].
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="short"/>.</returns>
    /// <exception cref="ArgumentNullException">The random generator is null.</exception>
    public static short GetRandomShort(StandardRandomGenerators generator)
    {
      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => RejectionGenerator.InternalGetRandomShort(),
        StandardRandomGenerators.CryptoServiceProvider => CryptoGenerator.InternalGetRandomShort(),
        _ => StandardGenerator.InternalGetRandomShort(),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="short"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="short"/>.</returns>
    public static short GetRandomShortII(StandardRandomGenerators generator, short minValue, short maxValue)
    {
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => (short)RejectionGenerator.InternalGetRandomIntII(minValue, maxValue),
        StandardRandomGenerators.CryptoServiceProvider => (short)CryptoGenerator.InternalGetRandomIntII(minValue, maxValue),
        _ => (short)StandardGenerator.InternalGetRandomIntII(minValue, maxValue),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="short"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="short"/>.</returns>
    public static short GetRandomShortEE(StandardRandomGenerators generator, short minValue, short maxValue)
    {
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => (short)RejectionGenerator.InternalGetRandomIntEE(minValue, maxValue),
        StandardRandomGenerators.CryptoServiceProvider => (short)CryptoGenerator.InternalGetRandomIntEE(minValue, maxValue),
        _ => (short)StandardGenerator.InternalGetRandomIntEE(minValue, maxValue),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="short"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="short"/>.</returns>
    public static short GetRandomShortIE(StandardRandomGenerators generator, short minValue, short maxValue)
    {
      // Throw an error if the min is greater than or equal to the max.
      if (minValue >= maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range, after adjustment, is equal.
      if (minValue == maxValue - 1)
        return minValue;

      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => (short)RejectionGenerator.InternalGetRandomIntIE(minValue, maxValue),
        StandardRandomGenerators.CryptoServiceProvider => (short)CryptoGenerator.InternalGetRandomIntIE(minValue, maxValue),
        _ => (short)StandardGenerator.InternalGetRandomIntIE(minValue, maxValue),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="short"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="short"/>.</returns>
    public static short GetRandomShortEI(StandardRandomGenerators generator, short minValue, short maxValue)
    {
      // Throw an error if the min is greater than or equal to the max.
      if (minValue >= maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range, after adjustment, is equal.
      if (minValue + 1 == maxValue)
        return minValue;

      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => (short)RejectionGenerator.InternalGetRandomIntEI(minValue, maxValue),
        StandardRandomGenerators.CryptoServiceProvider => (short)CryptoGenerator.InternalGetRandomIntEI(minValue, maxValue),
        _ => (short)StandardGenerator.InternalGetRandomIntEI(minValue, maxValue),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="ushort"/> on the range of
    /// [<see cref="ushort.MinValue"/>, <see cref="ushort.MaxValue"/>].
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="ushort"/>.</returns>
    /// <exception cref="ArgumentNullException">The random generator is null.</exception>
    public static ushort GetRandomUShort(this System.Random random)
    {
      // If the generator is not null, return a random ushort on the full range.
      if (random != null)
        return random.InternalGetRandomUShort();
      // If null, throw an error.
      throw new ArgumentNullException(nameof(random), "Random generator is null.");
    }

    /// <summary>
    /// A function for generating any <see cref="ushort"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="ushort"/>.</returns>
    public static ushort GetRandomUShortII(this System.Random random, ushort minValue, ushort maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (ushort)random.InternalGetRandomIntII(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="ushort"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="ushort"/>.</returns>
    public static ushort GetRandomUShortEE(this System.Random random, ushort minValue, ushort maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (ushort)random.InternalGetRandomIntEE(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="ushort"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="ushort"/>.</returns>
    public static ushort GetRandomUShortIE(this System.Random random, ushort minValue, ushort maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (ushort)random.InternalGetRandomIntIE(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="ushort"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="ushort"/>.</returns>
    public static ushort GetRandomUShortEI(this System.Random random, ushort minValue, ushort maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (ushort)random.InternalGetRandomIntEI(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="ushort"/> on the range of
    /// [<see cref="ushort.MinValue"/>, <see cref="ushort.MaxValue"/>].
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="ushort"/>.</returns>
    /// <exception cref="ArgumentNullException">The random generator is null.</exception>
    public static ushort GetRandomUShort(this RandomNumberGenerator random)
    {
      // If the generator is not null, return a random ushort on the full range.
      if (random != null)
        return random.InternalGetRandomUShort();
      // If null, throw an error.
      throw new ArgumentNullException(nameof(random), "Random generator is null.");
    }

    /// <summary>
    /// A function for generating any <see cref="ushort"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="ushort"/>.</returns>
    public static ushort GetRandomUShortII(this RandomNumberGenerator random, ushort minValue, ushort maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (ushort)random.InternalGetRandomIntII(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="ushort"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="ushort"/>.</returns>
    public static ushort GetRandomUShortEE(this RandomNumberGenerator random, ushort minValue, ushort maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (ushort)random.InternalGetRandomIntEE(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="ushort"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="ushort"/>.</returns>
    public static ushort GetRandomUShortIE(this RandomNumberGenerator random, ushort minValue, ushort maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (ushort)random.InternalGetRandomIntIE(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="ushort"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="ushort"/>.</returns>
    public static ushort GetRandomUShortEI(this RandomNumberGenerator random, ushort minValue, ushort maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return (ushort)random.InternalGetRandomIntEI(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="ushort"/> on the range of
    /// [<see cref="ushort.MinValue"/>, <see cref="ushort.MaxValue"/>].
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="ushort"/>.</returns>
    /// <exception cref="ArgumentNullException">The random generator is null.</exception>
    public static ushort GetRandomUShort(StandardRandomGenerators generator)
    {
      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => RejectionGenerator.InternalGetRandomUShort(),
        StandardRandomGenerators.CryptoServiceProvider => CryptoGenerator.InternalGetRandomUShort(),
        _ => StandardGenerator.InternalGetRandomUShort(),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="ushort"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="ushort"/>.</returns>
    public static ushort GetRandomUShortII(StandardRandomGenerators generator, ushort minValue, ushort maxValue)
    {
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => (ushort)RejectionGenerator.InternalGetRandomIntII(minValue, maxValue),
        StandardRandomGenerators.CryptoServiceProvider => (ushort)CryptoGenerator.InternalGetRandomIntII(minValue, maxValue),
        _ => (ushort)StandardGenerator.InternalGetRandomIntII(minValue, maxValue),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="ushort"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="ushort"/>.</returns>
    public static ushort GetRandomUShortEE(StandardRandomGenerators generator, ushort minValue, ushort maxValue)
    {
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => (ushort)RejectionGenerator.InternalGetRandomIntEE(minValue, maxValue),
        StandardRandomGenerators.CryptoServiceProvider => (ushort)CryptoGenerator.InternalGetRandomIntEE(minValue, maxValue),
        _ => (ushort)StandardGenerator.InternalGetRandomIntEE(minValue, maxValue),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="ushort"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="ushort"/>.</returns>
    public static ushort GetRandomUShortIE(StandardRandomGenerators generator, ushort minValue, ushort maxValue)
    {
      // Throw an error if the min is greater than or equal to the max.
      if (minValue >= maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range, after adjustment, is equal.
      if (minValue == maxValue - 1)
        return minValue;

      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => (ushort)RejectionGenerator.InternalGetRandomIntIE(minValue, maxValue),
        StandardRandomGenerators.CryptoServiceProvider => (ushort)CryptoGenerator.InternalGetRandomIntIE(minValue, maxValue),
        _ => (ushort)StandardGenerator.InternalGetRandomIntIE(minValue, maxValue),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="ushort"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="ushort"/>.</returns>
    public static ushort GetRandomUShortEI(StandardRandomGenerators generator, ushort minValue, ushort maxValue)
    {
      // Throw an error if the min is greater than or equal to the max.
      if (minValue >= maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range, after adjustment, is equal.
      if (minValue + 1 == maxValue)
        return minValue;

      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => (ushort)RejectionGenerator.InternalGetRandomIntEI(minValue, maxValue),
        StandardRandomGenerators.CryptoServiceProvider => (ushort)CryptoGenerator.InternalGetRandomIntEI(minValue, maxValue),
        _ => (ushort)StandardGenerator.InternalGetRandomIntEI(minValue, maxValue),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="int"/> on the range of
    /// [<see cref="int.MinValue"/>, <see cref="int.MaxValue"/>].
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    /// <exception cref="ArgumentNullException">The random generator is null.</exception>
    public static int GetRandomInt(this System.Random random)
    {
      // If the generator is not null, return a random int on the full range.
      if (random != null)
        return random.InternalGetRandomInt();
      // If null, throw an error.
      throw new ArgumentNullException(nameof(random), "Random generator is null.");
    }

    /// <summary>
    /// A function for generating any <see cref="int"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    public static int GetRandomIntII(this System.Random random, int minValue, int maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return random.InternalGetRandomIntII(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="int"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    public static int GetRandomIntEE(this System.Random random, int minValue, int maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return random.InternalGetRandomIntEE(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="int"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    public static int GetRandomIntIE(this System.Random random, int minValue, int maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than or equal to the max.
      if (minValue >= maxValue)
        throw new BadMinMaxException(minValue, maxValue, false);
      // Return min immediately if the range, after adjustment, is equal.
      if (minValue == maxValue - 1)
        return minValue;

      // If all checks clear, get a random integer.
      return random.InternalGetRandomIntIE(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="int"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    public static int GetRandomIntEI(this System.Random random, int minValue, int maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than or equal to the max.
      if (minValue >= maxValue)
        throw new BadMinMaxException(minValue, maxValue, false);
      // Return min immediately if the range, after adjustment, is equal.
      if (minValue + 1 == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return random.InternalGetRandomIntEI(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="int"/> on the range of
    /// [<see cref="int.MinValue"/>, <see cref="int.MaxValue"/>].
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    /// <exception cref="ArgumentNullException">The random generator is null.</exception>
    public static int GetRandomInt(this RandomNumberGenerator random)
    {
      // If the generator is not null, return a random int on the full range.
      if (random != null)
        return random.InternalGetRandomInt();
      // If null, throw an error.
      throw new ArgumentNullException(nameof(random), "Random generator is null.");
    }

    /// <summary>
    /// A function for generating any <see cref="int"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    public static int GetRandomIntII(this RandomNumberGenerator random, int minValue, int maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return random.InternalGetRandomIntII(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="int"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    public static int GetRandomIntEE(this RandomNumberGenerator random, int minValue, int maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return random.InternalGetRandomIntEE(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="int"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    public static int GetRandomIntIE(this RandomNumberGenerator random, int minValue, int maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than or equal to the max.
      if (minValue >= maxValue)
        throw new BadMinMaxException(minValue, maxValue, false);
      // Return min immediately if the range, after adjustment, is equal.
      if (minValue == maxValue - 1)
        return minValue;

      // If all checks clear, get a random integer.
      return random.InternalGetRandomIntIE(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="int"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This variant is for cryptographic randon generators.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    public static int GetRandomIntEI(this RandomNumberGenerator random, int minValue, int maxValue)
    {
      // Throw an error if the generator is null.
      if (random == null)
        throw new ArgumentNullException(nameof(random), "Passed-in Random generator was null.");
      // Throw an error if the min is greater than or equal to the max.
      if (minValue >= maxValue)
        throw new BadMinMaxException(minValue, maxValue, false);
      // Return min immediately if the range, after adjustment, is equal.
      if (minValue + 1 == maxValue)
        return minValue;

      // If all checks clear, get a random integer.
      return random.InternalGetRandomIntEI(minValue, maxValue);
    }

    /// <summary>
    /// A function for generating any <see cref="int"/> on the range of
    /// [<see cref="int.MinValue"/>, <see cref="int.MaxValue"/>].
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    /// <exception cref="ArgumentNullException">The random generator is null.</exception>
    public static int GetRandomInt(StandardRandomGenerators generator)
    {
      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => RejectionGenerator.InternalGetRandomInt(),
        StandardRandomGenerators.CryptoServiceProvider => CryptoGenerator.InternalGetRandomInt(),
        _ => StandardGenerator.InternalGetRandomInt(),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="int"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    public static int GetRandomIntII(StandardRandomGenerators generator, int minValue, int maxValue)
    {
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => RejectionGenerator.InternalGetRandomIntII(minValue, maxValue),
        StandardRandomGenerators.CryptoServiceProvider => CryptoGenerator.InternalGetRandomIntII(minValue, maxValue),
        _ => StandardGenerator.InternalGetRandomIntII(minValue, maxValue),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="int"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    public static int GetRandomIntEE(StandardRandomGenerators generator, int minValue, int maxValue)
    {
      // Throw an error if the min is greater than the max.
      if (minValue > maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range is equal.
      if (minValue == maxValue)
        return minValue;

      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => RejectionGenerator.InternalGetRandomIntEE(minValue, maxValue),
        StandardRandomGenerators.CryptoServiceProvider => CryptoGenerator.InternalGetRandomIntEE(minValue, maxValue),
        _ => StandardGenerator.InternalGetRandomIntEE(minValue, maxValue),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="int"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    public static int GetRandomIntIE(StandardRandomGenerators generator, int minValue, int maxValue)
    {
      // Throw an error if the min is greater than or equal to the max.
      if (minValue >= maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range, after adjustment, is equal.
      if (minValue == maxValue - 1)
        return minValue;

      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => RejectionGenerator.InternalGetRandomIntIE(minValue, maxValue),
        StandardRandomGenerators.CryptoServiceProvider => CryptoGenerator.InternalGetRandomIntIE(minValue, maxValue),
        _ => StandardGenerator.InternalGetRandomIntIE(minValue, maxValue),
      };
    }

    /// <summary>
    /// A function for generating any <see cref="int"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This variant is for selecting one of the global number generators.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    public static int GetRandomIntEI(StandardRandomGenerators generator, int minValue, int maxValue)
    {
      // Throw an error if the min is greater than or equal to the max.
      if (minValue >= maxValue)
        throw new BadMinMaxException(minValue, maxValue, true);
      // Return min immediately if the range, after adjustment, is equal.
      if (minValue + 1 == maxValue)
        return minValue;

      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => RejectionGenerator.InternalGetRandomIntEI(minValue, maxValue),
        StandardRandomGenerators.CryptoServiceProvider => CryptoGenerator.InternalGetRandomIntEI(minValue, maxValue),
        _ => StandardGenerator.InternalGetRandomIntEI(minValue, maxValue),
      };
    }

    /// <summary>
    /// An internal function for generating random values, and storing them into a byte array.
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="bytes">The array to store the values into. This must be sized to the number of
    /// bytes to generate.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static void InternalGetRandomBytes(this System.Random random, byte[] bytes)
    {
      random.NextBytes(bytes); // Get bytes as normal.
    }

    /// <summary>
    /// An internal function for generating random values, and storing them into a byte array.
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="count">The number of bytes to generate. This must be greater than 0.</param>
    /// <param name="bytes">The array of generated bytes.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static void InternalGetRandomBytes(this System.Random random, int count, out byte[] bytes)
    {
      // Create the correctly sized byte array and return the bytes.
      bytes = new byte[count];
      random.NextBytes(bytes);
    }

    /// <summary>
    /// An internal function for generating random values, and storing them into a byte array.
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="count">The number of bytes to generate. This must be greater than 0.</param>
    /// <returns>Returns the generated byte array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static byte[] InternalGetRandomBytes(this System.Random random, int count)
    {
      // Create the correctly sized byte array and return the bytes.
      byte[] bytes = new byte[count];
      random.NextBytes(bytes);
      return bytes;
    }

    /// <summary>
    /// An internal function for generating random values, and storing them into a byte array.
    /// This variant is for cryptographic randon generators.
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="bytes">The array to store the values into. This must be sized to the number of
    /// bytes to generate.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static void InternalGetRandomBytes(this RandomNumberGenerator random, byte[] bytes)
    {
      random.GetBytes(bytes); // Get bytes as normal.
    }

    /// <summary>
    /// An internal function for generating random values, and storing them into a byte array.
    /// This variant is for cryptographic randon generators.
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="count">The number of bytes to generate. This must be greater than 0.</param>
    /// <param name="bytes">The array of generated bytes.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static void InternalGetRandomBytes(this RandomNumberGenerator random, int count, out byte[] bytes)
    {
      // Create the correctly sized byte array and return the bytes.
      bytes = new byte[count];
      random.GetBytes(bytes);
    }

    /// <summary>
    /// An internal function for generating random values, and storing them into a byte array.
    /// This variant is for cryptographic randon generators.
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="count">The number of bytes to generate. This must be greater than 0.</param>
    /// <returns>Returns the generated byte array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static byte[] InternalGetRandomBytes(this RandomNumberGenerator random, int count)
    {
      // Create the correctly sized byte array and return the bytes.
      random.InternalGetRandomBytes(count, out byte[] bytes);
      return bytes;
    }

    /// <summary>
    /// A function for generating random values, and storing them into a byte array.
    /// This variant is for selecting one of the global number generators.
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="bytes">The array to store the values into. This must be sized to the number of
    /// bytes to generate.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static void InternalGetRandomBytes(StandardRandomGenerators generator, byte[] bytes)
    {
      // Use the appropriate global generator, based on the enum.
      switch (generator)
      {
        case StandardRandomGenerators.RejectionRandom:
          RejectionGenerator.InternalGetRandomBytes(bytes);
          break;
        case StandardRandomGenerators.CryptoServiceProvider:
          CryptoGenerator.InternalGetRandomBytes(bytes);
          break;
        default:
          StandardGenerator.InternalGetRandomBytes(bytes);
          break;
      }
    }

    /// <summary>
    /// A function for generating random values, and storing them into a byte array.
    /// This variant is for selecting one of the global number generators.
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="count">The number of bytes to generate. This must be greater than 0.</param>
    /// <param name="bytes">The array of generated bytes.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static void InternalGetRandomBytes(StandardRandomGenerators generator, int count, out byte[] bytes)
    {
      // Use the appropriate global generator, based on the enum.
      switch (generator)
      {
        case StandardRandomGenerators.RejectionRandom:
          RejectionGenerator.InternalGetRandomBytes(count, out bytes);
          break;
        case StandardRandomGenerators.CryptoServiceProvider:
          CryptoGenerator.InternalGetRandomBytes(count, out bytes);
          break;
        default:
          StandardGenerator.InternalGetRandomBytes(count, out bytes);
          break;
      }
    }

    /// <summary>
    /// A function for generating random values, and storing them into a byte array.
    /// This variant is for selecting one of the global number generators.
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="generator">The global random generator to use.</param>
    /// <param name="count">The number of bytes to generate. This must be greater than 0.</param>
    /// <returns>Returns the generated byte array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static byte[] InternalGetRandomBytes(StandardRandomGenerators generator, int count)
    {
      // Use the appropriate global generator, based on the enum.
      return generator switch
      {
        StandardRandomGenerators.RejectionRandom => RejectionGenerator.InternalGetRandomBytes(count),
        StandardRandomGenerators.CryptoServiceProvider => CryptoGenerator.InternalGetRandomBytes(count),
        _ => StandardGenerator.InternalGetRandomBytes(count),
      };
    }

    /// <summary>
    /// An internal function for generating any <see cref="sbyte"/> on the range of
    /// [<see cref="sbyte.MinValue"/>, <see cref="sbyte.MaxValue"/>].
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="sbyte"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static sbyte InternalGetRandomSByte(this System.Random random)
    {
      // Generate a random byte, and cast it to an sbyte. Values past 127 loop to negative.
      return (sbyte)random.InternalGetRandomBytes(sizeof(byte))[0];
    }

    /// <summary>
    /// An internal function for generating any <see cref="sbyte"/> on the range of
    /// [<see cref="sbyte.MinValue"/>, <see cref="sbyte.MaxValue"/>].
    /// This variant is for cryptographic randon generators.
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="sbyte"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static sbyte InternalGetRandomSByte(this RandomNumberGenerator random)
    {
      // Generate a random byte, and cast it to an sbyte. Values past 127 loop to negative.
      return (sbyte)random.InternalGetRandomBytes(sizeof(byte))[0];
    }

    /// <summary>
    /// An internal function for generating any <see cref="byte"/> on the range of
    /// [<see cref="byte.MinValue"/>, <see cref="byte.MaxValue"/>].
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="byte"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static byte InternalGetRandomByte(this System.Random random)
    {
      // Generate a random byte.
      return random.InternalGetRandomBytes(sizeof(byte))[0];
    }

    /// <summary>
    /// An internal function for generating any <see cref="byte"/> on the range of
    /// [<see cref="byte.MinValue"/>, <see cref="byte.MaxValue"/>].
    /// This variant is for cryptographic randon generators.
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="byte"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static byte InternalGetRandomByte(this RandomNumberGenerator random)
    {
      // Generate a random byte.
      return random.InternalGetRandomBytes(sizeof(byte))[0];
    }

    /// <summary>
    /// An internal function for generating any <see cref="short"/> on the range of
    /// [<see cref="short.MinValue"/>, <see cref="short.MaxValue"/>].
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="short"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static short InternalGetRandomShort(this System.Random random)
    {
      // Generate a random byte array the size of an short, and convert it.
      random.InternalGetRandomBytes(sizeof(short), out byte[] bytes);
      return BitConverter.ToInt16(bytes, 0);
    }

    /// <summary>
    /// An internal function for generating any <see cref="short"/> on the range of
    /// [<see cref="short.MinValue"/>, <see cref="short.MaxValue"/>].
    /// This variant is for cryptographic randon generators.
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="short"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static short InternalGetRandomShort(this RandomNumberGenerator random)
    {
      // Generate a random byte array the size of an short, and convert it.
      random.InternalGetRandomBytes(sizeof(short), out byte[] bytes);
      return BitConverter.ToInt16(bytes, 0);
    }

    /// <summary>
    /// An internal function for generating any <see cref="ushort"/> on the range of
    /// [<see cref="ushort.MinValue"/>, <see cref="ushort.MaxValue"/>].
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="ushort"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static ushort InternalGetRandomUShort(this System.Random random)
    {
      // Generate a random byte array the size of a ushort, and convert it.
      random.InternalGetRandomBytes(sizeof(ushort), out byte[] bytes);
      return BitConverter.ToUInt16(bytes, 0);
    }

    /// <summary>
    /// An internal function for generating any <see cref="ushort"/> on the range of
    /// [<see cref="ushort.MinValue"/>, <see cref="ushort.MaxValue"/>].
    /// This variant is for cryptographic randon generators.
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="ushort"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static ushort InternalGetRandomUShort(this RandomNumberGenerator random)
    {
      // Generate a random byte array the size of a ushort, and convert it.
      random.InternalGetRandomBytes(sizeof(ushort), out byte[] bytes);
      return BitConverter.ToUInt16(bytes, 0);
    }

    /// <summary>
    /// An internal function for generating any <see cref="int"/> on the range of
    /// [<see cref="int.MinValue"/>, <see cref="int.MaxValue"/>].
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int InternalGetRandomInt(this System.Random random)
    {
      // Generate a random byte array the size of an int, and convert it.
      random.InternalGetRandomBytes(sizeof(int), out byte[] bytes);
      return BitConverter.ToInt32(bytes, 0);
    }

    /// <summary>
    /// An internal function for generating any <see cref="int"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int InternalGetRandomIntII(this System.Random random, int minValue, int maxValue)
    {
      // Get the difference between the max and min. The max difference is the max uint value.
      uint difference = (uint)(maxValue - minValue);
      // If the difference is for the full inclusive int range, return using the byte method.
      if (difference == uint.MaxValue)
        return random.InternalGetRandomInt();

      difference += 1; // Add an extra point, as any Next function is inherently [I, E).

      // When maxValue is an int's max value, special care needs to be used by shifting down by
      // 1, then adding one after generating a value.
      if (maxValue == int.MaxValue)
        return random.Next(minValue - 1, (int)(minValue - 1 + difference)) + 1;

      // Otherwise, simply return on the given range. Add 1 due to [I, E) returns on Next.
      return random.Next(minValue, maxValue + 1);
    }

    /// <summary>
    /// An internal function for generating any <see cref="int"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The exclusive minimum value allowed.</param>
    /// <param name="maxValue">The exclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int InternalGetRandomIntEE(this System.Random random, int minValue, int maxValue)
    {
      // Shift minValue by 1 due to exclusivity and return on the new range.
      return random.Next(minValue + 1, maxValue);
    }

    /// <summary>
    /// An internal function for generating any <see cref="int"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The exclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int InternalGetRandomIntIE(this System.Random random, int minValue, int maxValue)
    {
      // Simply return on the given range.
      return random.Next(minValue, maxValue);
    }

    /// <summary>
    /// An internal function for generating any <see cref="int"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The exclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int InternalGetRandomIntEI(this System.Random random, int minValue, int maxValue)
    {
      minValue += 1; // Shift minValue by 1 due to exclusivity.

      // Get the difference between the max and min. The max difference is the max uint value.
      uint difference = (uint)(maxValue - minValue);

      difference += 1; // Add an extra point, as any Next function is inherently [I, E).

      // When maxValue is an int's max value, special care needs to be used by shifting down by
      // 1, then adding one after generating a value.
      if (maxValue == int.MaxValue)
        return random.Next(minValue - 1, (int)(minValue - 1 + difference)) + 1;

      // Otherwise, simply return on the given range. Add 1 due to [I, E) returns on Next.
      return random.Next(minValue, maxValue + 1);
    }

    /// <summary>
    /// An internal function for generating any <see cref="int"/> on the range of
    /// [<see cref="int.MinValue"/>, <see cref="int.MaxValue"/>].
    /// This variant is for cryptographic randon generators.
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int InternalGetRandomInt(this RandomNumberGenerator random)
    {
      // Generate a random byte array the size of an int, and convert it.
      random.InternalGetRandomBytes(sizeof(int), out byte[] bytes);
      return BitConverter.ToInt32(bytes, 0);
    }

    /// <summary>
    /// An internal function for generating any <see cref="int"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int InternalGetRandomIntII(this RandomNumberGenerator random, int minValue, int maxValue)
    {
      // Get the difference between the min and max values.
      // NOTE: The original implementation does not cast either minValue or maxValue to a long,
      // resulting in generating numbers within (min, min + ABS(Max) - ABS(min)) due to overflow.
      long difference = (long)maxValue - minValue;

      // If the difference is the full int range, merely return using the byte method.
      if (difference == uint.MaxValue)
        return random.InternalGetRandomInt();

      difference += 1; // Increase difference by one, due to the new inclusivity of the maxValue.

      byte[] bytes = new byte[sizeof(uint)]; // Create a byte array.

      long max = (1 + (long)uint.MaxValue); // Get the real max value we can hold.
      long remainder = max % difference; // Get the modulo remainder.
      long maxAllowedRandomValue = max - remainder; // Get the max value allowed to pass.

      uint value; // The randomly generated value.

      // Generating with cryptographic safety is slow, as it requires this while loop.
      // Larger ranges are faster. The value must be less than the allowed maximum.
      do
      {
        // Generate a random uint, to keep positive.
        random.InternalGetRandomBytes(bytes);
        value = BitConverter.ToUInt32(bytes, 0);
      }
      while (value >= maxAllowedRandomValue);

      // Modulo the value to fix the range and return it.
      return (int)(minValue + (value % difference));
    }

    /// <summary>
    /// An internal function for generating any <see cref="int"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The exclusive minimum value allowed.</param>
    /// <param name="maxValue">The exclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int InternalGetRandomIntEE(this RandomNumberGenerator random, int minValue, int maxValue)
    {
      uint value; // The randomly generated value.

      // Get the difference between the min and max values.
      // NOTE: The original implementation does not cast either minValue or maxValue to a long,
      // resulting in generating numbers within (min, min + ABS(Max) - ABS(min)) due to overflow.
      long difference = (long)maxValue - (minValue + 1);
      byte[] bytes = new byte[sizeof(uint)]; // Create a byte array.

      long max = (1 + (long)uint.MaxValue); // Get the real max value we can hold.
      long remainder = max % difference; // Get the modulo remainder.
      long maxAllowedRandomValue = max - remainder; // Get the max value allowed to pass.

      // Generating with cryptographic safety is slow, as it requires this while loop.
      // Larger ranges are faster. The value must be less than the allowed maximum.
      do
      {
        // Generate a random uint, to keep positive.
        random.InternalGetRandomBytes(bytes);
        value = BitConverter.ToUInt32(bytes, 0);
      }
      while (value >= maxAllowedRandomValue);

      // Modulo the value to fix the range and return it.
      return (int)(minValue + 1 + (value % difference));
    }

    /// <summary>
    /// An internal function for generating any <see cref="int"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The exclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int InternalGetRandomIntIE(this RandomNumberGenerator random, int minValue, int maxValue)
    {
      uint value; // The randomly generated value.

      // Get the difference between the min and max values.
      // NOTE: The original implementation does not cast either minValue or maxValue to a long,
      // resulting in generating numbers within (min, min + ABS(Max) - ABS(min)) due to overflow.
      long difference = (long)maxValue - minValue;
      byte[] bytes = new byte[sizeof(uint)]; // Create a byte array.

      long max = (1 + (long)uint.MaxValue); // Get the real max value we can hold.
      long remainder = max % difference; // Get the modulo remainder.
      long maxAllowedRandomValue = max - remainder; // Get the max value allowed to pass.

      // Generating with cryptographic safety is slow, as it requires this while loop.
      // Larger ranges are faster. The value must be less than the allowed maximum.
      do
      {
        // Generate a random uint, to keep positive.
        random.InternalGetRandomBytes(bytes);
        value = BitConverter.ToUInt32(bytes, 0);
      }
      while (value >= maxAllowedRandomValue);

      // Modulo the value to fix the range and return it.
      return (int)(minValue + (value % difference));
    }

    /// <summary>
    /// An internal function for generating any <see cref="int"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The exclusive minimum value allowed.</param>
    /// <param name="maxValue">The exclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="int"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int InternalGetRandomIntEI(this RandomNumberGenerator random, int minValue, int maxValue)
    {
      uint value; // The randomly generated value.

      // Get the difference between the min and max values.
      // NOTE: The original implementation does not cast either minValue or maxValue to a long,
      // resulting in generating numbers within (min, min + ABS(Max) - ABS(min)) due to overflow.
      long difference = (long)maxValue - minValue;
      byte[] bytes = new byte[sizeof(uint)]; // Create a byte array.

      long max = (1 + (long)uint.MaxValue); // Get the real max value we can hold.
      long remainder = max % difference; // Get the modulo remainder.
      long maxAllowedRandomValue = max - remainder; // Get the max value allowed to pass.

      // Generating with cryptographic safety is slow, as it requires this while loop.
      // Larger ranges are faster. The value must be less than the allowed maximum.
      do
      {
        // Generate a random uint, to keep positive.
        random.InternalGetRandomBytes(bytes);
        value = BitConverter.ToUInt32(bytes, 0);
      }
      while (value >= maxAllowedRandomValue);

      // Modulo the value to fix the range and return it.
      return (int)(minValue + 1 + (value % difference));
    }

    /// <summary>
    /// An internal function for generating any <see cref="uint"/> on the range of
    /// [<see cref="uint.MinValue"/>, <see cref="uint.MaxValue"/>].
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <returns>Returns a randomly generated <see cref="uint"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static uint InternalGetRandomUInt(this System.Random random)
    {
      // Generate a random byte array the size of an uint, and convert it.
      random.InternalGetRandomBytes(sizeof(uint), out byte[] bytes);
      return BitConverter.ToUInt32(bytes, 0);
    }

    /// <summary>
    /// An internal function for generating any <see cref="uint"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="uint"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static uint InternalGetRandomUIntII(this System.Random random, uint minValue, uint maxValue)
    {
      // Get the difference between the max and min. The max difference is the max uint value.
      uint difference = maxValue - minValue;
      // If the difference is for the full inclusive uint range, return using the byte method.
      if (difference == uint.MaxValue)
        return random.InternalGetRandomUInt();

      difference += 1; // Add an extra point, as any Next function is inherently [I, E).

      // When the difference is less than an int's max value, we can perform a standard Next.
      if (difference < int.MaxValue)
        return (uint)random.Next(0, (int)difference) + minValue;

      // Otherwise, special care is needed to handle wrapping around the normally negative values.
      // Get the wrapped values, and use it to create a wrap after the min value.
      long wrap = (long)int.MaxValue - difference;
      return (uint)(random.Next((int)wrap, int.MaxValue) - wrap + minValue);
    }

    /// <summary>
    /// An internal function for generating any <see cref="uint"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The exclusive minimum value allowed.</param>
    /// <param name="maxValue">The exclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="uint"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static uint InternalGetRandomUIntEE(this System.Random random, uint minValue, uint maxValue)
    {
      // Shift minValue and maxValue by 1 due to exclusivity and return on the new range.
      return random.InternalGetRandomUIntIE(minValue + 1, maxValue);
    }

    /// <summary>
    /// An internal function for generating any <see cref="uint"/> on the range of
    /// [<paramref name="minValue"/>, <paramref name="maxValue"/>).
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The inclusive minimum value allowed.</param>
    /// <param name="maxValue">The exclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="uint"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static uint InternalGetRandomUIntIE(this System.Random random, uint minValue, uint maxValue)
    {
      // Get the difference between the max and min. The max difference is the max uint value.
      uint difference = maxValue - minValue;

      // When the difference is less than an int's max value, we can perform a standard Next.
      if (difference < int.MaxValue)
        return (uint)random.Next(0, (int)difference) + minValue;

      // Otherwise, special care is needed to handle wrapping around the normally negative values.
      // Get the wrapped values, and use it to create a wrap after the min value.
      long wrap = (long)int.MaxValue - difference;
      return (uint)((long)random.Next((int)wrap, int.MaxValue) - wrap + minValue);
    }

    /// <summary>
    /// An internal function for generating any <see cref="uint"/> on the range of
    /// (<paramref name="minValue"/>, <paramref name="maxValue"/>].
    /// This is inlined, with no error checking. Public functions handle error checking.
    /// </summary>
    /// <param name="random">The random generator to use.</param>
    /// <param name="minValue">The exclusive minimum value allowed.</param>
    /// <param name="maxValue">The inclusive maximum value allowed.</param>
    /// <returns>Returns a randomly generated <see cref="uint"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static uint InternalGetRandomUIntEI(this System.Random random, uint minValue, uint maxValue)
    {
      // Shift minValue by 1 due to exclusivity and return on the new range.
      return random.InternalGetRandomUIntII(minValue + 1, maxValue);
    }
  }
}